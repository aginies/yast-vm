/**
 * File:	modules/VM_XEN.ycp
 * Package:	XEN specific functions and values
 * Authors:	Ladislav Slezak <lslezak@suse.cz>
 * $Id:$
 */
{
    module "VM_XEN";

    import "VM_Common";
    import "Report";
    import "HTML";

    textdomain "vm";

    list <map <string,any> > default_disks = [ $["size" : 1024, "sparse" : false, "target" : "hda" ] ];
    global list <map <string,any> > disks = default_disks;

    global string MAC_address = "";

    string domain_prefix = "domain";

    string kernel_path = "";

    string initrd_path = "";

    string xm = "/usr/sbin/xm";

    string img_prefix = "/var/lib/xen/images/";

    global boolean setMemorySize(integer msize)
    {
	VM_Common::memory_size = msize;
	return true;
    }

    global integer getMemorySize()
    {
	return VM_Common::memory_size;
    }

    global boolean resetMemorySize()
    {
	VM_Common::memory_size = VM_Common::default_memory_size;
	return true;
    }

    global string getAvailableMemory() {
	// xm info | grep free_memory

	return "";
    }

    global boolean setStartMode(string mode)
    {
	y2internal("start_mode: %1", mode);
	VM_Common::start_mode = mode;
	return true;
    }

    global string getStartMode()
    {
	return VM_Common::start_mode;
    }

    global boolean resetStartMode()
    {
	VM_Common::start_mode = VM_Common::default_start_mode;
	return true;
    }

    global boolean setMAC(string mac)
    {
	y2internal("MAC address: %1", mac);
	VM_Common::MAC_address = mac;
	return true;
    }

    global string getMAC()
    {
	return VM_Common::MAC_address;
    }

    global boolean resetMAC()
    {
	VM_Common::MAC_address= VM_Common::default_MAC;
	return true;
    }

    global integer FreeMemory() {
	// run 'xm info command'
	string cmd = "/usr/sbin/xm info | grep free_memory";

	map out = (map)SCR::Execute(.target.bash_output, cmd);
	y2debug("free_memory out: %1", out);

	list<string> output = splitstring(out["stdout"]:"", "\n");
	string free_line = output[0]:"";

	string msize = regexpsub(free_line, "free_memory[ \t]*:[ \t]*(.*)", "\\1");
	y2debug("memory size: %1", msize);

	return tointeger(msize);
    }

    global map<string,any> getOptionsProposal()
    {
	list<string> tmp = [];

	// Proposal for virtual machine installation
	tmp = add (tmp, sformat (_("Name of Virtual Machine: %1"), VM_Common::config_name));

	// Proposal for virtual machine installation
	tmp = add (tmp, sformat (_("Memory Size: %1 MB"), getMemorySize()));

	y2internal("mode: %1", getStartMode());

	// Proposal for virtual machine installation - %1 is a start mode (On boot/Manually)
	tmp = add (tmp, sformat (_("Activation: %1"),
				 VM_Common::start_mode_names[getStartMode()]:_("Unknown")));

	if (VM_Common::extra_args != "")
	{
	    // part of proposal text, %1 are extra kernel options
	    tmp = add (tmp, sformat (_("Boot Options: %1"), VM_Common::extra_args));
	}

	map<string,any> ret = $[ "preformatted_proposal" :
		 HTML::List (tmp)
	];


	// check available free memory
	integer fm = FreeMemory();

	if (getMemorySize() > fm)
	{
	    // error in the installation proposal - don't allow to continue
	    ret = add(ret, "warning", sformat(_("Not enough free memory (%1MB available)."), fm));
	    ret = add(ret, "warning_level", `blocker);
	}

	return ret;
    }

    global define boolean setDiskConfig(list<map<string,any> > dconf)
    {
	disks = dconf;
	return true;
    }

    global define list<map<string,any> > getDiskConfig() {
	return disks;
    }

    global define boolean resetDiskConfig() {
	disks = default_disks;
	return true;
    }

    global define list<string> getDiskProposal() {
	list<string> ret = [];

	integer i = 1;
	foreach (map<string,any> d, VM_XEN::disks, ``{
	    // Disk name for installation proposal
	    // %1 is a number, %2 size of disk, %3 is "(sparse image)" if it's set
	    ret = add (ret, sformat (_("Disk /dev/%1: %2 MB %3"), d["target"]:"", d["size"]:0, (d["sparse"]:false) ? _("(sparse file)") : ""));
	    i = i + 1;
	});

	return ret;
    }

    global define string getSourceProposal() {
	y2debug("source configuration: %1, %2, %3", VM_Common::inst_type, VM_Common::source_id, VM_Common::custom_source);
	return VM_Common::CreateSourceProposal(VM_Common::inst_type, VM_Common::source_id, VM_Common::custom_source);
    }

    global define boolean resetSourceConfig() {
	VM_Common::source_id = VM_Common::ProposeSelection();
	return true;
    }

    global define map<string,any> getSourceConfig() {
	return $[ "source_id" : VM_Common::source_id, "inst_type" : VM_Common::inst_type, "custom_source" : VM_Common::custom_source ];
    }

    global define string ProposeConfigName()
    {
	// start from 1, domain0 is used for the host system
	integer domain = 1;

	list<string> configs = SCR::Dir(.etc.xen.section);

	while (contains(configs, "/etc/xen/" + domain_prefix + tostring(domain)))
	{
	    domain = domain + 1;
	}

	y2internal("Proposed name: %1", domain_prefix + tostring(domain));

	return domain_prefix + tostring(domain);
    }

    global define boolean resetConfigName()
    {
	VM_Common::config_name = ProposeConfigName();
	return true;
    }

    global define boolean setSourceConfig(integer sid, symbol type, string custom) {

	VM_Common::source_id = sid;
	VM_Common::inst_type = type;
	VM_Common::custom_source = custom;

	return true;
    }

    global string getConfigName() {
	return VM_Common::config_name;
    }

    global boolean setConfigName(string cname) {
	VM_Common::config_name = cname;
	return true;
    }

    global define string ExtractXENKernelImage(string package, string target) {
	string tmpdir = VM_Common::GetTmpDir();
	string cmd = sformat("cd %1; /usr/bin/rpm2cpio %2 | /usr/bin/cpio -idvum './boot/vmlinuz-*-xen'", tmpdir, package);

	map out = (map)SCR::Execute(.target.bash_output, cmd);
	y2internal("out: %1", out);

	cmd = sformat("/usr/bin/find %1 -type f -name 'vmlinuz-*-xen'", tmpdir + "/boot");
	out = (map)SCR::Execute(.target.bash_output, cmd);
	y2internal("out: %1", out);

	list<string> stdout = splitstring(out["stdout"]:"", "\n");
	string file = stdout[0]:"";

	y2internal("found kernel: %1", file);

	if (file != nil && file != "")
	{
	    cmd = sformat("/bin/cp -a %1 %2", file, target);
	    out = (map)SCR::Execute(.target.bash_output, cmd);
	    y2internal("out: %1", out);

	    list<string> kpath = splitstring(file, "/");

	    return kpath[size(kpath) - 1]:"";
	}

	return "";;
    }

    global define boolean CreateInstallationImage(string kernelpkg, string target) {
	// get installation package
	string inst = VM_Common::GetPackage("install-initrd", "suse/i586");
	y2internal("image rpm: %1", inst);

	if (inst == nil || inst == "")
	{
	    y2error("Cannot obtain install-initrd package.");
	    return false;
	}

	string tmpdir = VM_Common::GetTmpDir();
	string cmd = sformat("cd %1; /usr/bin/rpm2cpio %2 | /usr/bin/cpio -idvum", tmpdir, inst);

	map out = (map)SCR::Execute(.target.bash_output, cmd);
	y2debug("out: %1", out);

	cmd = sformat("/bin/ls -1 %1/*.gz", tmpdir + "/usr/lib/install-initrd");
	out = (map)SCR::Execute(.target.bash_output, cmd);
	y2debug("out: %1", out);

	list<string> stdout = splitstring(out["stdout"]:"", "\n");
	y2debug("found base initrd files: %1", stdout);

	string file = stdout[0]:"";
	y2internal("found initrd: %1", file);

	// create the image
	cmd = sformat("%1/usr/sbin/mkinstallinitrd --kernel-rpm %2 --libdir %3 %4", tmpdir, kernelpkg, tmpdir + "/usr/lib/install-initrd", target);
	out = (map)SCR::Execute(.target.bash_output, cmd);
	y2internal("mkinstallinitrd output: %1", out);

	return out["exit"]:1 == 0;
    }

    boolean WriteOption(path configpath, string optname, string optvalue) {
	return (boolean)SCR::Write(configpath + topath(optname), optvalue);
    }

    boolean WriteStringOption(path configpath, string optname, string optvalue) {
	return WriteOption(configpath, optname, "\"" + optvalue + "\"");
    }

    string formatDiskConfig(list<map<string,any> > conf, string pref) {
	string ret = "";

	foreach(map<string,any> d, conf, {
		string f = pref + "/" + d["target"]:"";

		if (size(ret) > 0)
		{
		    ret = ret + ", ";
		}

		ret = ret + sformat("'file:%1,%2,w'", f, d["target"]:"");
	    }
	);

	ret = "[ " + ret + " ]";

	y2milestone("Disk configuration: %1", ret);

	return ret;
    }

    define integer IsInstSourceDefined(string url) {
	list<integer> sources = Pkg::SourceGetCurrent (false);
	integer ret = -1;

	foreach(integer src, sources, {
		map general_data = Pkg::SourceGeneralData(src);
		if (url == general_data["url"]:"")
		{
		    ret = src;
		}
	    }
	);

	return ret;
    }

    define map<integer,boolean> InstSourceStatus() {
	map<integer,boolean> ret = $[];

	list<integer> sources = Pkg::SourceGetCurrent(false);

	foreach(integer src, sources, {
		map general_data = Pkg::SourceGeneralData(src);
		y2internal("general_data: %1", general_data);
		y2internal("product_data: %1", Pkg::SourceProductData(src));
		ret[src] = general_data["enabled"]:false;
	    }
	);

	return ret;
    }

    define map<string,string> DisableAllSources() {
	map<string,string> ret = $[];

	list<integer> sources = Pkg::SourceGetCurrent (false);

	foreach(integer src, sources, {
		Pkg::SourceSetEnabled(src, false);
	    }
	);

	return ret;
    }

    define void SetSourceState(map<integer,boolean> state) {
	list<integer> sources = Pkg::SourceGetCurrent (false);
	foreach(integer src, boolean enabled, state, {
		Pkg::SourceSetEnabled(src, enabled);
	    }
	);
    }


    global define boolean Write() {
	// TODO check whether the config file already exists
	y2internal("Writing the config to file %1", "/etc/xen/" + VM_Common::config_name);

	path configpath = .etc.xen.value + topath("/etc/xen/" + VM_Common::config_name);

	boolean ret = WriteOption(configpath, "disk", formatDiskConfig(disks, img_prefix + VM_Common::config_name));
	ret = ret && WriteOption(configpath, "memory", tostring(VM_Common::memory_size));
	ret = ret && WriteStringOption(configpath, "kernel", kernel_path);

	ret = ret && WriteStringOption(configpath, "ramdisk", initrd_path);

	ret = ret && WriteStringOption(configpath, "name", VM_Common::config_name);

	ret = ret && WriteStringOption(configpath, "dhcp", "dhcp");

	if (VM_Common::MAC_address != nil && VM_Common::MAC_address != "")
	{
	    ret = ret && WriteStringOption(configpath, "vif", sformat("[ 'mac=%1' ]", VM_Common::MAC_address));
	}

	ret = ret && WriteStringOption(configpath, "restart", "never");

	// set installation source
	string url = "";

	if (VM_Common::inst_type == `configured)
	{
	    map general_data = Pkg::SourceGeneralData (VM_Common::source_id);
	    url = general_data["url"]:"";
	}
	else if (VM_Common::inst_type == `custom)
	{
	    url = VM_Common::custom_source;
	}
	else if (VM_Common::inst_type == `slp)
	{
	    url = "slp://";
	}

	ret = ret && WriteStringOption(configpath, "extra", "TERM=xterm textmode=1 install=" + url + " " + VM_Common::extra_args);

	// flush the changes
	ret = ret && SCR::Write(.etc.xen, nil);

	if (VM_Common::start_mode == "onboot")
	{
	    // create 'auto' link if the VM should be started at boot time
	    string cmd = "cd /etc/xen/auto; /bin/ln -s ../" + VM_Common::config_name;
	    integer link_result = (integer)SCR::Execute(.target.bash, cmd);

	    if (link_result != 0)
	    {
		y2warning("Cannot set automatic start, link failed (exit code: %1)", link_result);
	    }
	}

	return ret;
    }


    define list<string> SearchFile(string dir, string name) {
	list<string> ret = [];
	string cmd = sformat("cd %1; ls -1 %2", dir, name);
	map outputmap = (map)SCR::Execute(.target.bash_output, cmd);

	string outputstring = outputmap["stdout"]:"";

	if (outputstring != nil && outputstring != "")
	{
	    ret = splitstring(outputstring, "\n");
	    // remove empty lines
	    ret = filter(string f, ret, {return f != nil && f != "";});
	}

	return ret;
    }

    define list<string> PartitionsInfo(string image) {
	string cmd = sformat("sfdisk -d -uS %1", image);
	map outputmap = (map)SCR::Execute(.target.bash_output, cmd);

	string outputstring = outputmap["stdout"]:"";

	list<string> ret = [];

	if (outputstring != nil && outputstring != "")
	{
	    ret = splitstring(outputstring, "\n");
	    // remove empty lines
	    ret = filter(string f, ret, {return f != nil && f != "";});
	}

	y2internal("PartitionsInfo (%1): %2", image, ret);

	return ret;
    }

    define list<map<string,string> > ParsePartitionInfo(list<string> info) {
	list<map<string,string> > ret = [];
	y2internal("Parse partition: %1", info);

	if (info != nil)
	{
	    foreach(string line, info, {
		    if (regexpmatch(line, " : start=.*, size=.*, Id="))
		    {
			// line contains partition description

			string expr = "(.*)[ \\t]*:[ \\t]*start=[ \\t]*([1234567890]*)[ \\t]*, size=[ \\t]*([1234567890]*)[ \\t]*, Id=[ \\t]*([1234567890abcdefABCDEF]*)";

			string pname = regexpsub(line, expr, "\\1");
			string pstart = regexpsub(line, expr, "\\2");
			string psize = regexpsub(line, expr, "\\3");
			string pid = regexpsub(line, expr, "\\4");

			if (pstart != nil && psize != nil && pid != nil)
			{
			    ret = add(ret, $["name" : pname, "start" : pstart, "size" : psize, "id" : pid]);
			}
		    }
		}
	    );
	}

	y2internal("Parsed output: %1", ret);

	return ret;
    }

    define boolean TryMount(string image, integer offset, string mntpoint) {
	boolean result = (boolean) SCR::Execute(.target.mount, [image, mntpoint], sformat("-o ro,loop,offset=%1", offset));
	return result;
    }

    define map<string,list<string> > SearchFiles(map<string,list<string> > search, string prefix) {
	map<string,list<string> >result = $[];

	// check files
	foreach(string file, list<string> dirs, search, {
		boolean found = false;

		foreach(string dir, dirs, {
			if (!found)
			{
			    list<string> foundfiles = SearchFile(prefix + "/" + dir, file);

			    if (size(foundfiles) > 0)
			    {
				// directory prefix
				foundfiles = maplist(string f, foundfiles, {return dir + f;});
				result[file] = foundfiles;
				found = true;
			    }
			}
		    }
		);


	    }
	);

	y2internal("result: %1", result);

	return result;
    }

    string ParseFstab(string fstab) {
        map out = (map) SCR::Execute(.target.bash_output, sformat("/bin/grep \" / \" %1 | /usr/bin/cut -f 1 -d \" \"",  fstab));
	string rdev = "";

	if (out["exit"]:-1 == 0 )
	{
	    rdev = (string) (out["stdout"]:"");
	    list<string> root_dev_list = splitstring(rdev, "\n");
	    rdev = root_dev_list[0]:"";
	    y2milestone("Found root device: %1", rdev);
	}
	else
	{
	    y2error("Cannot read fstab root device entry: %1", out);
	}

	return rdev;
    }

    define boolean CopyFile(string source, string target) {
	y2milestone("copying file %1 to %2", source, target);
	// -a (archive) = preserve mode and timestamps
	// -b (backup) = make a backup of the target file
	return (SCR::Execute(.target.bash, sformat("/bin/cp -a -b %1 %2", source, target))) == 0;
    }

    define string GetFileNameFromPath(string fname) {
	string ret = "";

	if (fname != nil)
	{
	    list<string> parts = splitstring(fname, "/");
	    ret = parts[size(parts) - 1]:"";
	}

	return ret;
    }

    define void ProcessFoundFile(map<string,list<string> > found, string dir) {
	if (found != nil && size(found) > 0)
	{
	    foreach(string file, list<string> location, found, {

		    if (size(location) > 1)
		    {
			y2warning("Using the first location from list: %1", location);
		    }

		    string filename = dir + "/" + location[0]:"";
		    string target_dir = img_prefix + VM_Common::config_name;

		    if (file == "fstab")
		    {
			// parse fstab file and set root device name
			VM_Common::root_device = ParseFstab(filename);
		    }
		    else if (file == "vmlinuz-*-xen")
		    {
			// copy kernel image
			CopyFile(filename, target_dir);
			// set kernel name
			kernel_path = target_dir + "/" + GetFileNameFromPath(filename);
		    }
		    else if (file == "initrd-*-xen")
		    {
			// copy initrd image
			CopyFile(filename, target_dir);
			// set initrd name
			initrd_path = target_dir + "/" + GetFileNameFromPath(filename);
		    }
		    else
		    {
			y2warning("Unknown file: %1", file);
		    }
		}
	    );
	}
    }

    define void ReadDiskImage(string diskimage)
    {
	list<string> pinfo = PartitionsInfo(diskimage);
	list<map<string,string> > partitions = ParsePartitionInfo(pinfo);

	// leave only Linux partitions
	partitions = filter(map<string,string> partition, partitions, {return partition["id"]:"" == "83";});
	y2internal("Linux partitions: %1", partitions);


	// create mountpoint directory
	string tmp = VM_Common::GetTmpDir();

	string mountpoint = tmp + "/mountpoint";

	// create mount point directory
	SCR::Execute(.target.mkdir, mountpoint);


	foreach(map<string,string> partition, partitions, {

	    integer offset = tointeger(partition["start"]:"") * 512;

	    if (offset != nil)
	    {
		boolean mounted = TryMount(diskimage, offset, mountpoint);

		if (mounted)
		{
		    // search for files
		    map<string,list<string> > search = $[
			"vmlinuz-*-xen" : [ "/boot/", "/" ],
			"initrd-*-xen" : [ "/boot/", "/" ],
			"fstab" : [ "/etc/", "/" ]
		    ];

		    map<string,list<string> > found = SearchFiles(search, mountpoint);

		    y2milestone("Search result: %1", found);

		    ProcessFoundFile(found, mountpoint);

		    // unmount the image
		    SCR::Execute(.target.umount, mountpoint);
		}
	    }

	});
    }


    define boolean ReadDiskImages(string prefix) {
	boolean ret = true;

	foreach(map<string,any> disk, disks, {
		string target = disk["target"]:"hda";
		ret = ret && ReadDiskImage(prefix + "/" + target);
	    }
	);

	return ret;
    }


    global define boolean Prepare2() {

	ReadDiskImages(img_prefix + VM_Common::config_name);

	SCR::UnmountAgent(.etc.xen);

	path configpath = .etc.xen.value + topath("/etc/xen/" + VM_Common::config_name);
	boolean ret = true;

	// upadate config - root device, set default runlevel, remove install= option
	ret = ret && SCR::Write(configpath + "restart", nil);

	string extra = "3 TERM=xterm";
	if (VM_Common::extra_args != "")
	{
	    extra = extra + " " + VM_Common::extra_args;
	}

	ret = ret && WriteStringOption(configpath, "extra", extra);
	ret = ret && WriteStringOption(configpath, "kernel", kernel_path);
	ret = ret && WriteStringOption(configpath, "ramdisk", initrd_path);
	ret = ret && WriteStringOption(configpath, "root", VM_Common::root_device);

	// flush the changes
	ret = ret && SCR::Write(.etc.xen, nil);

	return true;
    }

    global define boolean Prepare3() {
	boolean ret = true;
	path configpath = .etc.xen.value + topath("/etc/xen/" + VM_Common::config_name);

	SCR::UnmountAgent(.etc.xen);

	// remove TERM option
	ret = ret && WriteStringOption(configpath, "extra", "3 " + VM_Common::extra_args);

	// flush the changes
	ret = ret && SCR::Write(.etc.xen, nil);

	return ret;
    }

    boolean CreateDiskImages(string prefix) {
	boolean ret = true;
	foreach(map<string,any> disk, disks, {
		integer imgsize = disk["size"]:1024;
		boolean sparse = disk["sparse"]:false;
		string target = disk["target"]:"hda";

		ret = ret && VM_Common::CreateDiskImage(prefix + "/" + target, imgsize, sparse);
	    }
	);

	return ret;
    }

    global define boolean Prepare() {
	// build/extract xen kernel and installation initrd, copy them to the target directory
	string target_dir = img_prefix + VM_Common::config_name;
	string cmd = "/bin/mkdir -p " + target_dir;
	map out = (map)SCR::Execute(.target.bash_output, cmd);
	y2debug("mkdir output: %1", out);


	// remember inst source config
	map<integer,boolean> src_status = InstSourceStatus();
	integer new_src = -1;
	y2internal("src_status: %1", src_status);

	// disable all sources
	DisableAllSources();
	integer enabled_src = VM_Common::source_id;
	y2internal("src_status: %1", InstSourceStatus());

	// check whether the custom installation source is already defined
	if (VM_Common::inst_type == `custom)
	{
	    string url = VM_Common::custom_source;
	    integer src_defined = IsInstSourceDefined(url);

	    if (src_defined < 0)
	    {
		// Add a new installation source
		new_src = Pkg::SourceCreate(url, "");
		y2milestone("Adding new installation source: %1 = %2", url, new_src);
		enabled_src = new_src;
		VM_Common::source_id = new_src;
		y2internal("src_status: %1", InstSourceStatus());
	    }
	}

	// enable the only one (selected) source
	Pkg::SourceSetEnabled(enabled_src, true);
	y2internal("enabled src %1: %2", enabled_src, InstSourceStatus());

	y2milestone("Extracting XEN kernel from the installation source...");
	string kpkg = VM_Common::GetPackage("kernel-xen", "suse/i586");
	kernel_path = ExtractXENKernelImage(kpkg, target_dir + "/");
	if (kernel_path != "")
	{
	    kernel_path = target_dir + "/" + kernel_path;
	}

	y2milestone("Creating installation ramdisk (initrd)...");
	CreateInstallationImage(kpkg, target_dir + "/inst-initrd");
	initrd_path = target_dir + "/inst-initrd";
	y2internal("kernel: %1, initrd: %2", kernel_path, initrd_path);

	// create disk image file(s)
	y2milestone("Creating disk images...");
	CreateDiskImages(target_dir);

	if (new_src >= 0)
	{
	    Pkg::SourceDelete(new_src);
	}

	// set source statuses back
	SetSourceState(src_status);

	return true;
    }

    global define boolean Start() {
	// start the VM in xterm session
	string cmd = sformat("/usr/bin/xterm -e %1 create -c /etc/xen/%2", xm, VM_Common::config_name);
	y2internal("command: %1", cmd);
	integer out = (integer)SCR::Execute(.target.bash, cmd);

	return out == 0;
    }

    global define string getExtraArgs() {
	return VM_Common::extra_args;
    }

    global define boolean setExtraArgs(string args) {
	VM_Common::extra_args = args;
	return true;
    }

    global define boolean resetExtraArgs() {
	VM_Common::extra_args = "";
	return true;
    }

    global define map GetFunctions()
    {
	return $[
	    "setMemorySize" : VM_XEN::setMemorySize,
	    "getMemorySize" : VM_XEN::getMemorySize,
	    "resetMemorySize" : VM_XEN::resetMemorySize,

	    "setStartMode" : VM_XEN::setStartMode,
	    "getStartMode" : VM_XEN::getStartMode,
	    "resetStartMode" : VM_XEN::resetStartMode,

	    "setMAC" : VM_XEN::setMAC,
	    "getMAC" : VM_XEN::getMAC,
	    "resetMAC" : VM_XEN::resetMAC,

	    "setConfigName" : VM_XEN::setConfigName,
	    "getConfigName" : VM_XEN::getConfigName,
	    "resetConfigName" : VM_XEN::resetConfigName,

	    "getOptionsProposal" : VM_XEN::getOptionsProposal,

	    "setDiskConfig" : VM_XEN::setDiskConfig,
	    "getDiskConfig" : VM_XEN::getDiskConfig,
	    "resetDiskConfig" : VM_XEN::resetDiskConfig,
	    "getDiskProposal" : VM_XEN::getDiskProposal,

	    "getSourceConfig" : VM_XEN::getSourceConfig,
	    "setSourceConfig" : VM_XEN::setSourceConfig,
	    "getSourceProposal" : VM_XEN::getSourceProposal,
	    "resetSourceConfig" : VM_XEN::resetSourceConfig,

	    "getExtraArgs"	: VM_XEN::getExtraArgs,
	    "setExtraArgs"	: VM_XEN::setExtraArgs,
	    "resetExtraArgs"	: VM_XEN::resetExtraArgs,

	    "Write" : VM_XEN::Write,
	    "Prepare" : VM_XEN::Prepare,
	    "Prepare2" : VM_XEN::Prepare2,
	    "Prepare3" : VM_XEN::Prepare3,
	    "Start"	: VM_XEN::Start,
	];
    }

    global void VM_XEN() ``{
	// propose selection
	resetSourceConfig();

	// propose configuration (domain) name
	resetConfigName();
    }
}
