/**
 * Module:	inst_vm_source.ycp
 *
 * Authors:	Ladislav Slezak <lslezak@suse.cz>
 *		Michael G. Fritch <mgfritch@novell.com>
 *
 * Purpose:	Ask the user for installation source for the virtual machine.
 *
 * $Id$
 *
 */
{
    textdomain "vm";

    import "VM";
    import "VM_Common";
    import "VM_XEN";
    import "URL";
    import "Label";
    import "Popup";
    import "Wizard";
    import "Report";
    import "Sequencer";
    import "String";

    // screen title - installation source configuration
    string title = _("Installation Source");


    list<integer> sources = Pkg::SourceGetCurrent (false);

    map<string,any> sconfig = VM::GetSourceConfig();

    define term create_item (integer index, integer id) ``{
        map product_data = Pkg::SourceProductData (id);
        map general_data = Pkg::SourceGeneralData (id);
	string srcurl = general_data["url"]:"";
	map parsed_url = URL::Parse(srcurl);
	if (!URL::Check(srcurl) || parsed_url["host"]:"" == "")	{
		return nil;
	}
	else {
		return `item (`id (index),
		      product_data["label"]:"unknown",
		      general_data["url"]:"");
	}
    }


    define void fill_table () ``{

	integer i = 0;
        list items = [];
	integer j = -1;

        while (i < size (sources))
	{
	    term new_item = create_item (i, sources[i]:0);
	    if (new_item != nil) items = add (items, new_item);
	    if (sources[i]:0 == sconfig["source_id"]:0)
		j = i;
	    i = i + 1;
        }

        UI::ChangeWidget (`id (`sources), `Items, items);
	if (j > -1)
	    UI::ChangeWidget (`id(`sources), `CurrentItem, j);
    }

    define void updateConfig(map<string,any> conf) {
	y2debug("updateConfig(%1)", conf);
	VM::SetSourceConfig(conf["source_id"]:0, conf["inst_type"]:`configured, conf["custom_source"]:"");
    }

    define void RefreshCD_SourceDialog() {
	any rb = UI::QueryWidget (`id(`rbg), `CurrentButton);

	// CD widgets
//	UI::ChangeWidget(`id(`cddev), `Enabled, (rb == `cdrom));
	UI::ChangeWidget(`id(`kernel_cd), `Enabled, (rb == `cdrom));
	UI::ChangeWidget(`id(`select_kernel_cd), `Enabled, (rb == `cdrom));
	UI::ChangeWidget(`id(`initrd_cd), `Enabled, (rb == `cdrom));
	UI::ChangeWidget(`id(`select_initrd_cd), `Enabled, (rb == `cdrom));
    }

    define void RefreshISO_SourceDialog() {
	any rb = UI::QueryWidget (`id(`rbg), `CurrentButton);

	// ISO widgets
//	UI::ChangeWidget(`id(`cdromimage), `Enabled, (rb == `iso));
//	UI::ChangeWidget(`id(`select_cdromimage), `Enabled, (rb == `iso));
	UI::ChangeWidget(`id(`kernel_iso), `Enabled, (rb == `iso));
	UI::ChangeWidget(`id(`select_kernel_iso), `Enabled, (rb == `iso));
	UI::ChangeWidget(`id(`initrd_iso), `Enabled, (rb == `iso));
	UI::ChangeWidget(`id(`select_initrd_iso), `Enabled, (rb == `iso));

    }


    /**
    * Popup dialog - source configuration
    * return symbol
    */
    define symbol SourceTypeDialog() {

	string caption = _("Operating System Installation");

	term contents =
	`MarginBox(1.5, 0.2, `VBox(
		`RadioButtonGroup(`id(`rbg),
			// heading in a popup dialog
			`Frame(_("Install Using"),
				`MarginBox(1.5, 0.2, `VBox(
					`Left(`RadioButton(`id(`net), `opt(`notify), _("Network Installation &Source"))),
					`VSpacing(0.5),
					`Left(`RadioButton(`id(`cdrom), `opt(`notify), _("&CD / DVD Device"))),
					`VSpacing(0.5),
					`Left(`RadioButton(`id(`iso), `opt(`notify), _("&ISO Image File")))
				))
			)
		),
		`VSpacing(2),
		`Frame(_("Installation Options"),
			`MarginBox(1.5, 0.2,
				`TextEntry(`id(`bootopts), `opt(`hstretch), "", VM::GetExtraArgs())))
	));

	string help_text = sformat(_("<p><b><big>%1</big></b></p>"), caption);
	help_text = help_text + _("<p>The VM's operating system can be installed from a YaST Network Installation Source, a CD / DVD device, or an ISO image file.</p>");
	help_text = help_text + _("<p>Any of these methods can be used to install SUSE operating systems.  Non-SUSE operating systems must be installed from a CD / DVD device or an ISO image file.</p>");
	help_text = help_text + _("<p><b>Installation Options</b> are optional arguments passed to the kernel during installation.</p>");


	Wizard::SetContents(caption, contents, help_text, true, true);

	symbol s = `dummy;

	if (VM::GetCustomKernel() && VM::GetCustomIso()) {
		UI::ChangeWidget(`id(`rbg), `CurrentButton, `iso);
	}
	else if (VM::GetCustomKernel()) {
		UI::ChangeWidget(`id(`rbg), `CurrentButton, `cdrom);
	}
	else {
		UI::ChangeWidget(`id(`rbg), `CurrentButton, `net);
	}

	while(!contains([`next, `back, `abort, `cancel, `fetch], s))
	{
	    s = (symbol) UI::UserInput();
	    y2milestone("s=%1", s);

//FIXME: popup confirmation for abort???
	    if (s == `next) {
		symbol type = (symbol) UI::QueryWidget (`id(`rbg), `CurrentButton);

		if (type == `cdrom || type == `iso) {
		    VM::SetCustomKernel(true);
		    if (type == `iso) VM::SetCustomIso(true);
		    else VM::SetCustomIso(false);

		    // set custom installation source
		    y2milestone("old sconfig: %1", sconfig);
		    sconfig["inst_type"] = `custom;
		    y2milestone("new sconfig: %1", sconfig);
		}
		else {
			VM::SetCustomKernel(false);
			VM::SetCustomIso(false);
		}

		string boot = (string) UI::QueryWidget (`id(`bootopts), `Value);
		VM::SetExtraArgs(boot);

		s = type;
		break;
	    }
	    else if (s == `net || s == `cdrom || s == `iso) {
		continue;
	    }
// FIXME: add catch for any unknown return values???
	}

	return s;
    }




    define symbol CD_SourceDialog() {

	string caption = _("Install Using a CD / DVD Device");

        list<string> cd_devs = [];
        list<term> cd_items = [];

        list<map> cd_hwinfo = (list<map>)SCR::Read(.probe.cdrom);

        if (cd_hwinfo != nil) {
            foreach(map dev, cd_hwinfo,
	    {
	        string device = dev["dev_name"]:"";
	        string model = dev["model"]:"";

	        y2milestone("CD-ROM model: %1, device: %2", model, device);

	        if (device != nil && device != "")
	        {
		    cd_devs = add(cd_devs, device);
		    // format CD device name: %1 is model name (e.g. "TOSHIBA DVD-ROM SD-M1402"), %2 is device name (e.g. /dev/hdc)
		    cd_items = add(cd_items, `item(`id(device), sformat(_("%1 (%2)"), model, device)/*, device == cd*/));
	        }
	    });
        }

	term contents =
		`MarginBox(1.5, 0.2, `VBox(
			`HBox(
//				`HSpacing(3),
				`ComboBox(`id(`cddev), _("&CD / DVD Device"), cd_items),
				`HStretch()
			),
			`VSpacing(2),
			`RadioButtonGroup(`id(`rbg),
				`Frame(_("CD / DVD Media Type"),
					`MarginBox(1.5, 1, `VBox(
						`Left(`RadioButton(`id(`extract), `opt(`notify), _("&SUSE Installation Source"))),
						`VSpacing(0.5),
						`Left(`RadioButton(`id(`cdrom), `opt(`notify), _("&Other Installation Source"))),
						`HBox(
							`HSpacing(3),
							`TextEntry(`id(`kernel_cd), `opt(`hstretch), _("&Xen-Enabled Kernel"), VM::GetKernelImage()),
							`HSpacing(1),
							`VBox(
								`Label(""),
								`PushButton(`id(`select_kernel_cd), _("Browse..."))
							)
						),
						`HBox(
							`HSpacing(3),
							`TextEntry(`id(`initrd_cd), `opt(`hstretch), _("&Installation File (initrd)"), VM::GetInitrdImage()),
							`HSpacing(1),
							`VBox(
								`Label(""),
								`PushButton(`id(`select_initrd_cd), _("Browse..."))
							)
						)
					))
				)
			)
		));

	string help_text = sformat(_("<p><b><big>%1</big></b></p>"), caption);
	help_text = help_text + _("<p>The VM's operating system will be installed from the selected <b>CD / DVD device</b>.</p>");
	help_text = help_text + _("<p>Specify whether the <b>CD / DVD media type</b> is a SUSE installation source, or some other type.  Using installation media other than SUSE requires you to designate the locations of the Xen-enabled kernel and, optionally, the initial installation program (initrd).  These files must be accessible on the VM Server's file system.</p>");

	Wizard::SetContents(caption, contents, help_text, true, true);

	UI::ChangeWidget(`id(`extract), `Enabled, false); //FIXME: this must be enabled when extract kernel and initrd are supported.

	symbol s = `dummy;

	if (VM::GetCustomKernel()) {
		UI::ChangeWidget(`id(`rbg), `CurrentButton, `cdrom);
	}
	else {
		UI::ChangeWidget(`id(`rbg), `CurrentButton, `extract);
	}

	// initialize the widgets
	RefreshCD_SourceDialog();

	while(!contains([`next, `back, `abort, `cancel, `fetch], s))
	{

	    s = (symbol) UI::UserInput();
	    y2milestone("s=%1", s);

	    RefreshCD_SourceDialog();

//FIXME: popup confirmation for abort???
	    if (s == `next) {
		symbol type = (symbol) UI::QueryWidget (`id(`rbg), `CurrentButton);
		string cddev = "";
		string kernel = "";
		string initrd = "";
		string old_cddev = sconfig["custom_source"]:""; // remember the old source, just in case it needs to be removed from the disks config


		if (type == `cdrom) {
			cddev = (string) UI::QueryWidget (`id(`cddev), `Value);
			kernel = (string) UI::QueryWidget (`id(`kernel_cd), `Value);
			initrd = (string) UI::QueryWidget (`id(`initrd_cd), `Value);
			if (cddev == nil || cddev == "") {
				Report::Error(_("A CD / DVD device name must be selected."));
				s = `again;
				continue;
			}
			// check whether the file exists
                    	if ((integer)SCR::Read(.target.size, cddev) < 0) {
				// %1 is file name
				Report::Error(_("The specified CD / DVD device does not exist, or
there is no media in the CD / DVD device.

Please ensure that the desired media is in the selected CD / DVD device.
"));
				continue;
			}


		    if (kernel == nil || kernel == "") {
			Report::Error(_("The kernel file name cannot be empty."));
			s = `again;
			continue;
		    }

		    VM::SetCustomKernel(true);
		    VM::SetCustomIso(false);

		    VM::SetKernelImage(kernel);
		    VM::SetInitrdImage(initrd);

		    // if NetWare always set localtime=1 in para virtualization
		    if (VM_Common::GetVirtualizationType() == "para" && VM_Common::IsNetWareKernel(kernel)) {
			VM::SetLocaltime(1);
		    }
		
		    // set custom installation source
		    y2milestone("old sconfig: %1", sconfig);
		    sconfig["inst_type"] = `custom;
		    sconfig["custom_source"] = cddev;
		    updateConfig(sconfig);
		    y2milestone("new sconfig: %1", sconfig);
		}

		// remove the old disk entry(old_source, if it exists in the disks configuration
		string old_source = regexpsub(old_cddev, "/dev/(.*)", "\\1");// remove /dev from the front of the string
		if (old_source == nil || old_source == "") {
			old_source = old_cddev; // fall back to cddev in case the regexp fails
		}
		if (old_source != nil && old_source != "") {
			y2milestone("Removing old disk source: %1", old_source);
			list<map<string,any> > disks = VM::GetDiskConfig();
			list<map<string,any> > new_disks = [];
			foreach(map<string,any> m, disks, ``{
				if (m["source"]:"" != old_source)
					new_disks = add(new_disks, m);
			});
			y2milestone("old disks=%1", disks);
			y2milestone("new disks=%1", new_disks);
			VM::SetDiskConfig(new_disks);
		}



		if (type == `cdrom) {
		    string source = "";
		    if (type == `cdrom) {
			source = regexpsub(cddev, "/dev/(.*)", "\\1");// remove /dev from the front of the string
		    }
		    if (source == nil || source == "") {
			source = cddev; // fall back to cddev in case the regexp fails
		    }

		    // add the cdrom/iso to the set of virtual disks
		    list<string> valid_targets = VM::GetValidVirtualDevices(VM::GetConfiguredDiskTargets(VM::GetDiskConfig()));
		    y2milestone("vaild_targets=%1", valid_targets);
		    if (valid_targets != nil && size(valid_targets) > 0) {
				string target = valid_targets[0]:"hdc";
				list<map<string,any> > disks = VM::GetDiskConfig();
				y2milestone("disks=%1", disks);
				map<string,any> new_disk = nil;
				if (type == `cdrom) 
					new_disk = $[ "source" : source, "target" : target, "ro" : true, "type" : "phys" ];
				else 
					new_disk = $[ "source" : source, "target" : target, "ro" : true, "type" : "loop-use" ];
				if (new_disk == nil) {
					y2error("new_disk is empty");
				}
				y2milestone("adding: %1", new_disk);
				disks = add(disks, new_disk);
				VM::SetDiskConfig(disks);
		    }
		    else {
			Report::Error(_("Cannot add a new virtual disk target."));
			y2error("WARNING: Cannot set the virtual target for the CD / DVD device.  All valid virtual targets are used!!!");
			continue;
		    }
		}
		else { // extract for inst source (SuSE)
		    s = `fetch;
		    VM::SetCustomKernel(false);
		    VM::SetCustomIso(false);
		}
	    }
	    else if (s == `select_kernel_cd) {
		string new_kernel = (string)UI::QueryWidget(`id(`kernel_cd), `Value);
		new_kernel = UI::AskForExistingFile(new_kernel, "*", _("Select Xen-Enabled Kernel"));

		if (new_kernel != nil)
		{
		    UI::ChangeWidget(`id(`kernel_cd), `Value, new_kernel);
		}
	    }
	    else if (s == `select_initrd_cd) {
		string new_initrd = (string)UI::QueryWidget(`id(`initrd_cd), `Value);
		new_initrd = UI::AskForExistingFile(new_initrd, "*", _("Select Initial RAM Disk"));

		if (new_initrd != nil)
		{
		    UI::ChangeWidget(`id(`initrd_cd), `Value, new_initrd);
		}
	    }
// FIXME: add catch for any unknown return values???
	}

	return s;
    }


    define symbol ISO_SourceDialog() {

	string caption = _("Install Using an ISO Image");

	term contents =
	`MarginBox(1.5, 0.2, `VBox(
		`HBox(
//			`HSpacing(3),
			`TextEntry(`id(`cdromimage), `opt(`hstretch), _("&ISO Image File")),
			`HSpacing(1),
			`VBox(
				`Label(""),
				`PushButton(`id(`select_cdromimage), _("Browse..."))
			)
		),
		`VSpacing(2),
		`RadioButtonGroup(`id(`rbg),
			// heading in a popup dialog
			`Frame(_("ISO Type"),
				`MarginBox(1.5, 1, `VBox(
					`Left(`RadioButton(`id(`extract), `opt(`notify), _("&SUSE Installation Source"))),
					`VSpacing(0.5),
					`Left(`RadioButton(`id(`iso), `opt(`notify), _("&Other Installation Source"))),
					`HBox(
						`HSpacing(3),
						`TextEntry(`id(`kernel_iso), `opt(`hstretch), _("&Xen-Enabled Kernel"), VM::GetKernelImage()),
						`HSpacing(1),
						`VBox(
							`Label(""),
							`PushButton(`id(`select_kernel_iso), _("Browse..."))
						)
					),
					`HBox(
						`HSpacing(3),
						`TextEntry(`id(`initrd_iso), `opt(`hstretch), _("&Installation File (initrd)"), VM::GetInitrdImage()),
						`HSpacing(1),
						`VBox(
							`Label(""),
							`PushButton(`id(`select_initrd_iso), _("Browse..."))
						)
					)
				))
			)
		)
	));

	string help_text = sformat(_("<p><b><big>%1</big></b></p>"), caption);
	help_text = help_text + _("If the installation source files are stored in an .ISO image file, you can specify its location on the VM Server's file system.</p>");
	help_text = help_text + _("<p>Specify whether the <b>ISO image file</b> is a SUSE installation source, or some other type. Using installation media other than SUSE requires you to designate the locations of the Xen-enabled kernel and, optionally, the initial installation program (initrd). These files must be accessible on the VM Server's file system.</p>");

	Wizard::SetContents(caption, contents, help_text, true, true);

	UI::ChangeWidget(`id(`extract), `Enabled, false); //FIXME: this must be enabled when extract kernel and initrd are supported.


	symbol s = `dummy;

	if (VM::GetCustomKernel() && VM::GetCustomIso()) {
		UI::ChangeWidget(`id(`rbg), `CurrentButton, `iso);
	}
	else {
		UI::ChangeWidget(`id(`rbg), `CurrentButton, `extract);
	}

	UI::ChangeWidget(`id(`cdromimage), `Value, (regexpmatch(sconfig["custom_source"]:"", ".*iso")) ? sconfig["custom_source"]:"" : "");

	// initialize the widgets
	RefreshISO_SourceDialog();

	while(!contains([`next, `back, `abort, `cancel, `fetch], s))
	{
	    s = (symbol) UI::UserInput();
	    y2milestone("s=%1", s);

//FIXME: popup confirmation for abort???
	    if (s == `next) {
		symbol type = (symbol) UI::QueryWidget (`id(`rbg), `CurrentButton);
		string cddev = "";
		string kernel = "";
		string initrd = "";
		string old_cddev = sconfig["custom_source"]:""; // remember the old source, just in case it needs to be removed from the disks config

		cddev = (string) UI::QueryWidget (`id(`cdromimage), `Value);
		if (cddev == nil || cddev == "") {
			Report::Error(_("ISO file name cannot be empty."));
			s = `again;
			continue;
		}

		if (type == `cdrom || type == `iso) {
			kernel = (string) UI::QueryWidget (`id(`kernel_iso), `Value);
			initrd = (string) UI::QueryWidget (`id(`initrd_iso), `Value);

		    if (kernel == nil || kernel == "") {
			Report::Error(_("The kernel file name cannot be empty."));
			s = `again;
			continue;
		    }

		    VM::SetCustomKernel(true);
		    if (type == `iso) VM::SetCustomIso(true);
		    else VM::SetCustomIso(false);

		    VM::SetKernelImage(kernel);
		    VM::SetInitrdImage(initrd);

		    // if NetWare always set localtime=1 in para virtualization
		    if (VM_Common::GetVirtualizationType() == "para" && VM_Common::IsNetWareKernel(kernel)) {
			VM::SetLocaltime(1);
		    }
		}

		// set custom installation source
		y2milestone("old sconfig: %1", sconfig);
		sconfig["inst_type"] = `custom;
		sconfig["custom_source"] = cddev;
		updateConfig(sconfig);
		y2milestone("new sconfig: %1", sconfig);
		
		// remove the old disk entry(old_source, if it exists in the disks configuration
		string old_source = regexpsub(old_cddev, "/dev/(.*)", "\\1");// remove /dev from the front of the string
		if (old_source == nil || old_source == "") {
			old_source = old_cddev; // fall back to cddev in case the regexp fails
		}
		if (old_source != nil && old_source != "") {
			y2milestone("Removing old disk source: %1", old_source);
			list<map<string,any> > disks = VM::GetDiskConfig();
			list<map<string,any> > new_disks = [];
			foreach(map<string,any> m, disks, ``{
				if (m["source"]:"" != old_source)
					new_disks = add(new_disks, m);
			});
			y2milestone("old disks=%1", disks);
			y2milestone("new disks=%1", new_disks);
			VM::SetDiskConfig(new_disks);
		}



		if (type == `cdrom || type == `iso) {
		    string source = "";
		    if (type == `cdrom) {
			source = regexpsub(cddev, "/dev/(.*)", "\\1");// remove /dev from the front of the string
		    }
		    if (source == nil || source == "") {
			source = cddev; // fall back to cddev in case the regexp fails
		    }

		    // add the cdrom/iso to the set of virtual disks
		    list<string> valid_targets = VM::GetValidVirtualDevices(VM::GetConfiguredDiskTargets(VM::GetDiskConfig()));
		    y2milestone("vaild_targets=%1", valid_targets);
		    if (valid_targets != nil && size(valid_targets) > 0) {
				string target = valid_targets[0]:"hdc";
				list<map<string,any> > disks = VM::GetDiskConfig();
				y2milestone("disks=%1", disks);
				map<string,any> new_disk = nil;
				if (type == `cdrom) 
					new_disk = $[ "source" : source, "target" : target, "ro" : true, "type" : "phys" ];
				else 
					new_disk = $[ "source" : source, "target" : target, "ro" : true, "type" : "loop-use" ];
				if (new_disk == nil) {
					y2error("new_disk is empty");
				}
				y2milestone("adding: %1", new_disk);
				disks = add(disks, new_disk);
				VM::SetDiskConfig(disks);
		    }
		    else {
			Report::Error(_("Cannot add a new virtual disk target."));
			y2error("WARNING: Cannot set the virtual target for the CD / DVD device.  All valid virtual targets are used!!!");
			continue;
		    }
		}
		else { // extract for inst source (SuSE)
		    s = `fetch;
		    VM::SetCustomKernel(false);
		    VM::SetCustomIso(false);
		}
	    }
	    else if (s == `select_kernel_cd) {
		string new_kernel = (string)UI::QueryWidget(`id(`kernel_cd), `Value);
		new_kernel = UI::AskForExistingFile(new_kernel, "*", _("Select Xen-Enabled Kernel"));

		if (new_kernel != nil)
		{
		    UI::ChangeWidget(`id(`kernel_cd), `Value, new_kernel);
		}
	    }
	    else if (s == `select_kernel_iso) {
		string new_kernel = (string)UI::QueryWidget(`id(`kernel_iso), `Value);
		new_kernel = UI::AskForExistingFile(new_kernel, "*", _("Select Xen-Enabled Kernel"));

		if (new_kernel != nil)
		{
		    UI::ChangeWidget(`id(`kernel_iso), `Value, new_kernel);
		}
	    }
	    else if (s == `select_initrd_cd) {
		string new_initrd = (string)UI::QueryWidget(`id(`initrd_cd), `Value);
		new_initrd = UI::AskForExistingFile(new_initrd, "*", _("Select Initial RAM Disk"));

		if (new_initrd != nil)
		{
		    UI::ChangeWidget(`id(`initrd_cd), `Value, new_initrd);
		}
	    }
	    else if (s == `select_initrd_iso) {
		string new_initrd = (string)UI::QueryWidget(`id(`initrd_iso), `Value);
		new_initrd = UI::AskForExistingFile(new_initrd, "*", _("Select Initial RAM Disk"));

		if (new_initrd != nil)
		{
		    UI::ChangeWidget(`id(`initrd_iso), `Value, new_initrd);
		}
	    }
	    else if (s == `select_cdromimage) {
		string cdimg = (string)(UI::QueryWidget(`id(`cdromimage), `Value));
		string new_img = UI::AskForExistingFile(cdimg, "*.iso", _("Select ISO Image"));
	
		if (new_img != nil)
		{
			UI::ChangeWidget(`id(`cdromimage), `Value, new_img);
		}
	    }
	    else if (s == `extract || s == `cdrom || s == `iso) {
		// refresh the dialog
		RefreshISO_SourceDialog();
	    }
// FIXME: add catch for any unknown return values???
	}

	return s;
    }



define symbol SourceSelection() {
    // build and show dialog
    integer indent = 3;
    string caption = _("Install Using a Network Installation Source");

    string default_custom_src = "";
    if (! regexpmatch(sconfig["custom_source"]:"", ".*iso") && ! regexpmatch(sconfig["custom_source"]:"", "/dev.*")) {
	default_custom_src = sconfig["custom_source"]:"";
    }
    boolean inst_type_configured = true;
    if (sconfig["inst_type"]:`unknown != `configured && default_custom_src != "") {
	inst_type_configured = false;
	
    }

    term contents = `VBox(
			`RadioButtonGroup(`id(`source), `opt(`notify),
			    `VBox(
				`VSpacing(0.3),
				// radio button label
				`Left(`RadioButton(`id(`configured),  `opt(`notify), _("&Configured Installation Source"),  inst_type_configured)),
				`VSpacing(0.3),
				`HBox(
				    `HSpacing(indent),
				    `Table(`id(`sources),
					// table column heading
					`header(_("Name"), _("URL")), [ ])
				),
				// push button label
				// installation source configuration module
				// is started when it's pressed
				`PushButton(`id(`inst_src), _("C&onfigure...")),
				`VSpacing(1),

				`Left(`RadioButton(`id(`custom),  `opt(`notify), _("Custom &Installation Source"), inst_type_configured == false)),
				`HBox(
				    `HSpacing(indent),
				    `TextEntry(`id(`custom_source), _("&URL of Installation Source"), default_custom_src)
				),
				`VSpacing(1)

// TODO: disabled, we need kernel package before starting VM, we MUST know the URL
//				`Left(`RadioButton(`id(`slp),  `opt(`notify), _("&SLP Installation Source"), sconfig["inst_type"]:`unknown == `slp)),
//				`VSpacing(1)
			    )
			)
		    );

    // help text for backup dialog during update 1/7
    string help_text = sformat(_("<P><B><big>%1</big></B></P>"), caption);
	help_text = help_text + _("<p>YaST provides a library for storing <b>SUSE installation source</b> files with their associated kernel and initial install programs (initrd).</p>");
	help_text = help_text + _("<p>Make sure to select an installation source that includes a Xen-enabled kernel.</p>");
	help_text = help_text + _("<P>Only network installation sources, such as FTP or NFS, are supported.</P>");

    Wizard::SetContents(caption, contents, help_text, true, true);

    fill_table();

    symbol ret = nil;

    while (true)
    {
	// refresh status of the widgets
	symbol selected = (symbol)(UI::QueryWidget(`id(`source), `CurrentButton));
	UI::ChangeWidget(`id(`sources), `Enabled, selected == `configured);
	UI::ChangeWidget(`id(`inst_src), `Enabled, selected == `configured);
	UI::ChangeWidget(`id(`custom_source), `Enabled, selected == `custom);

	ret = (symbol) Wizard::UserInput ();

	if (ret == `abort || ret == `cancel) {
		if (Popup::ReallyAbort(VM_Common::GetModified()))
			break;
	}
	else if (ret == `back) {
	    break;
	}
	else if (ret == `next) {
	    // check if selected installation source is valid
	    integer current = (integer) UI::QueryWidget (`id(`sources), `CurrentItem);

	    y2milestone("sources: %1, current: %2", sources, current);
	    integer current_srcid = -1;
	    if (size(sources) > 0)
	    {
		current_srcid = sources[current]:0;
	    }

	    symbol selected_type = (symbol)UI::QueryWidget(`id(`source), `CurrentButton);
	    string selected_custom_source = (string)UI::QueryWidget(`id(`custom_source), `Value);
	    string srcurl = "";

	    if (selected_type == `configured)
	    {
		if (current_srcid >= 0)
		{
		    map general_data = Pkg::SourceGeneralData(current_srcid);
		    srcurl = general_data["url"]:"";
		}
	    }
	    else
	    {
		srcurl = selected_custom_source;
	    }

	    map parsed_url = URL::Parse(srcurl);

	    if (!URL::Check(srcurl) || parsed_url["host"]:"" == "") // FIXME: why the check for parsed_url["host"]???  Shouldn't physical media (CD / DVD) work fine?
//	    if (!URL::Check(srcurl))
	    {
		Report::Error(_("Entered URL value is not valid."));
	    }
	    else
	    {
		y2debug("Selected source: %1", srcurl);
		sconfig["inst_type"] = selected_type;

		if (selected_type == `configured)
		{
		    sconfig["source_id"] = current_srcid;
		}
		else if (selected_type == `custom)
		{
		    sconfig["custom_source"] = selected_custom_source;
		}
		else
		{
		    y2error("Unknown installation type");
		}

		updateConfig(sconfig);

		break;
	    }
/*	    else
	    {
		Report::Error(_("Only network installation sources
are supported in the installation."));
	    }*/
	}
	else if (ret == `inst_src) {
	    // start installation source configuration module
	    WFM::CallFunction("inst_source", []);
	    // refresh table content
	    sources = Pkg::SourceGetCurrent(false);
	    fill_table();
	}
    }

    return ret;
}

define void RefreshFullOptionsDialog()
{
    symbol enabled = (symbol) UI::QueryWidget (`id(`rb_group), `CurrentButton);

    UI::ChangeWidget(`id(`cdromimage), `Enabled, enabled == `iso);
    UI::ChangeWidget(`id(`select_file), `Enabled, enabled == `iso);

    UI::ChangeWidget(`id(`cddev), `Enabled, enabled == `cdrom);
}

define symbol FullOptionsDialog()
{
    // screen title for the Xen mode selection
    string caption = _("Operating System Installation");

    map<string,string> fulloption = VM_XEN::GetFullOptions();
    string cd = fulloption["cdrom_image"]:"";
    string boot = fulloption["boot_device"]:"c";

    y2milestone("VTx config: cdrom_image: %1, boot_device: %2", cd, boot);

    list<string> cd_devs = [];
    list<term> cd_items = [];

    list<map> cd_hwinfo = (list<map>)SCR::Read(.probe.cdrom);

    if (cd_hwinfo != nil) {
	foreach(map dev, cd_hwinfo,
	{
	    string device = dev["dev_name"]:"";
	    string model = dev["model"]:"";

	    y2milestone("CD-ROM model: %1, device: %2", model, device);

	    if (device != nil && device != "")
	    {
		cd_devs = add(cd_devs, device);
		// format CD device name: %1 is model name (e.g. "TOSHIBA DVD-ROM SD-M1402"), %2 is device name (e.g. /dev/hdc)
		cd_items = add(cd_items, `item(`id(device), sformat(_("%1 (%2)"), model, device), device == cd));
	    }
	}
	);
    }

    term contents =
	`MarginBox(1.5, 0.2,
		`Frame(_("Install Using"),
			`MarginBox(0.5, 0.5,
				`RadioButtonGroup(`id(`rb_group),
					`VBox(
						`Left(`RadioButton(`id(`cdrom), `opt(`notify), _("&CD / DVD Device"), boot == "d" && contains(cd_devs, cd))),
						`HBox(
							`HSpacing(3),
							`ComboBox(`id(`cddev), _("&Device Name"), cd_items),
							`HStretch()
						),
						`VSpacing(1),
						`Left(`RadioButton(`id(`iso), `opt(`notify), _("&ISO Image File"), boot == "d" && !contains(cd_devs, cd))),
						`HBox(
							`HSpacing(3),
							`TextEntry(`id(`cdromimage), `opt(`hstretch), _("&File Name"), boot == "d" && !contains(cd_devs, cd) ? cd : ""),
							`HSpacing(1),
							`VBox(
								`Label(""),
								`PushButton(`id(`select_file), _("Br&owse..."))
							),
							`HSpacing(1)
						)
					)
				)
			)
		)
	);


    // help text for OS selection in full virtualization mode (1/2)
    string help_text = sformat(_("<p><b><big>%1</big></b></p>"), caption);
    // help text for OS selection in full virtualization mode (2/2)
    help_text = help_text + _("<p>The installation of the operating system can be started from a physical CD / DVD or an ISO image file.</p>");

    Wizard::SetContents (caption, contents, help_text, true, true);

    UI::ChangeWidget(`id(`rb_group), `CurrentButton, `cdrom);

    symbol ret = nil;

    while (true) {
	RefreshFullOptionsDialog();

	ret = (symbol) Wizard::UserInput();

	if (ret == `abort || ret == `cancel) {
		if (Popup::ReallyAbort(VM_Common::GetModified()))
			break;
	}
	else if (ret == `back) {
	    break;
	}
	else if (ret == `next) {
	    symbol bootdev_symbol = (symbol)(UI::QueryWidget(`id(`rb_group), `CurrentButton));
	    string bootdev = (bootdev_symbol == `disk) ? "c" : "d";

	    y2milestone("bootdev_symbol: %1",  bootdev_symbol);
	    y2milestone("bootdev: %1", bootdev);

	    string cdimg = "";

	    if (bootdev_symbol == `cdrom)
	    {
		cdimg = (string)(UI::QueryWidget(`id(`cddev), `Value));
	    }
	    else
	    {
		cdimg = (string)(UI::QueryWidget(`id(`cdromimage), `Value));
	    }

	    if (bootdev_symbol == `iso && cdimg == "")
	    {
		// error - entered empty ISO image file name
		Report::Error(_("Select an ISO image file for CD-ROM emulation."));
	    }
	    else
	    {
		map<string,string> opts = $["boot_device":bootdev, "cdrom_image":cdimg];
		y2milestone("Full virtualization options: %1", opts);
		VM_XEN::SetFullOptions( opts );
		break;
	    }
	}
	else if (ret == `select_file) {
	    string cdimg = (string)(UI::QueryWidget(`id(`cdromimage), `Value));
	    string new_img = UI::AskForExistingFile(cdimg, "*.iso", _("Select ISO Image"));

	    if (new_img != nil)
	    {
		UI::ChangeWidget(`id(`cdromimage), `Value, new_img);
	    }
	}
	else {
		y2error("unexpected retcode: %1", ret);
		continue;
	}
    }

    return ret;
}


/**
 * dialog - boot options configuration
 * @return symbol dialog result
 */
define symbol BootOptionsDialog() {
	// figure out what disks are configured.
	list<string> used_targets = VM::GetConfiguredDiskTargets(VM::GetDiskConfig());
	// propose some partions based on the configured disks.
	list<string> valid_partitions = [];
	foreach (string target, used_targets, {
		if (target != nil && target != "") {
			list<string> postfix = [];
			if (findfirstof(target, String::CDigit()) != nil) {// already contains partition.
				postfix = [ target ];
			}
			else {
				postfix = ["1", "2", "3", "4", "5", "6"];
				postfix = maplist(string postchar, postfix, { return target + postchar; });
			}
			valid_partitions = (list<string>) union(valid_partitions, postfix);
		}
	});
	valid_partitions = toset(valid_partitions); //sort list and remove duplicates

	string caption = _("Operating System Boot Files");
	
	term contents =
		`MarginBox(1.5, 0.2, `VBox(
			`Frame(_("Boot Using"),
				`MarginBox(1.5, 0.2, `VBox(
					`ComboBox(`id(`device), `opt(`editable,`hstretch), _("&Partition Containing Boot Files"), valid_partitions),
					`VSpacing(0.5),
					`TextEntry(`id(`kernel), `opt(`hstretch), _("&Xen-Enabled Kernel"), VM::GetKernelImage()),
					`VSpacing(0.5),
					`TextEntry(`id(`initrd), `opt(`hstretch), _("Boot &File (initrd)"), VM::GetInitrdImage())
				))
			),
			`VSpacing(2),
			`Frame(_("Boot Options"),
				`MarginBox(1.5, 0.2,
				`TextEntry(`id(`bootopts), `opt(`hstretch), "", VM::GetExtraArgs()))
			)
		));

	string help_text = sformat(_("<p><b><big>%1</big></b></p>"), caption);
	help_text = help_text + _("<p>The VM boots its operating system using the <b>kernel</b> and <b>boot file</b> stored on a virtual disk. Specify the partition that holds these files and the location of each. For example, partition: <tt>hda1</tt>; location of <b>kernel</b>: <tt>/boot/vmlinuz-xen</tt>; and location of <b>boot file</b>: <tt>/boot/initrd-xen.</tt></p>");
	help_text = help_text + _("<p><b>Boot options</b> are optional arguments passed to the kernel each time it boots.</p>");

	Wizard::SetContents(caption, contents, help_text, true, true);

	UI::ChangeWidget (`id(`device), `Value, VM_Common::root_device);

	symbol ui = `dummy;
	while(!contains([`next, `back, `abort, `cancel], ui)) {

		ui = (symbol) UI::UserInput();
		y2milestone("ui=%1", ui);

		if (ui == `abort || ui == `cancel) {
			if (!Popup::ReallyAbort(VM_Common::GetModified()))
				ui = `again;
				continue;
		}
		else if (ui == `next) {
			string device = (string) UI::QueryWidget (`id(`device), `Value);
			string kernel = (string) UI::QueryWidget (`id(`kernel), `Value);
			string initrd = (string) UI::QueryWidget (`id(`initrd), `Value);
			string bootopts = (string) UI::QueryWidget (`id(`bootopts), `Value);
	
			if (device == nil || device == "") {
				Report::Error(_("Partition Containing Kernel and RAM Disk cannot be empty."));
				ui = `again;
				continue;
			}
		// make sure the device is a defined virtual disk...
		boolean success = false;
		foreach(string target, used_targets, {
			if (issubstring(device, target)) success = true;
		});
		if (!success) {
			if (!Popup::ContinueCancelHeadline(_("Warning"), _("The Partition Containing Kernel and RAM Disk,
does not match any configued disks."))) {
				ui = `again;
				continue;
			}
		}

			if (kernel == nil || kernel == "") {
				Report::Error(_("Xen-Enabled Kernel cannot be empty."));
				ui = `again;
				continue;
			}

/*			if (initrd == nil || initrd == "") {
				Report::Error(_("RAM Disk cannot be empty."));
				s = `again;
				continue;
			}*/
	
			VM::SetCustomKernel(true);
	
			VM::SetKernelImage(kernel);
			VM::SetInitrdImage(initrd);
			VM_Common::root_device = device;
	
			VM::SetExtraArgs(bootopts);
		}
		// FIXME: add catch for any unknown return values???
	}
	return ui;
}



    Wizard::OpenNextBackDialog();

    map aliases = $[
	    "SourceTypeDialog"	: ``(SourceTypeDialog()),
	    "SourceSelection"	: ``(SourceSelection()),
	    "CD_SourceDialog": ``(CD_SourceDialog()),
	    "ISO_SourceDialog": ``(ISO_SourceDialog()),
	    "FullOptionsDialog"	: ``(FullOptionsDialog()),
	    "BootOptionsDialog"	: ``(BootOptionsDialog())
	];

    map sequence = $[
	    // start differnt workflow for full virtualization mode
	    "ws_start"	: (VM::GetVirtualizationType() == "full") ? "FullOptionsDialog" : ((VM_Common::proposal_type == "install") ? "SourceTypeDialog" : "BootOptionsDialog"),
	    "SourceTypeDialog"	:
		$[
		    `net	    :	"SourceSelection",
		    `cdrom	    : 	"CD_SourceDialog",
		    `iso	    :	"ISO_SourceDialog",
		    `abort	    :   `abort,
		    `next	    :   `next
		],
	    "SourceSelection"	:
		$[
		    `abort	    :	`abort,
		    `next	    :	`next
		],
	    "CD_SourceDialog"	:
		$[
		    `abort	    :	`abort,
		    `next	    :	`next
		],
	    "ISO_SourceDialog"	:
		$[
		    `abort	    :	`abort,
		    `next	    :	`next
		],
	    "FullOptionsDialog"	:
		$[
		    `abort	    :   `abort,
		    `next	    :   `next
		],
	    "BootOptionsDialog" :
		$[
		    `abort	    :	`abort,
		    `next	    :   `next
		]
	    ];

    symbol ret = Sequencer::Run(aliases, sequence);

    Wizard::CloseDialog();

    return ret;

}
