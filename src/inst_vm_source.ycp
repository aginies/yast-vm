/**
 * Module:	inst_vm_source.ycp
 *
 * Authors:	Ladislav Slezak <lslezak@suse.cz>
 *
 * Purpose:	Ask the user for installation source for the virtual machine.
 *
 * $Id$
 *
 */
{
    textdomain "vm";

    import "VM";
    import "VM_Common";
    import "VM_XEN";
    import "URL";
    import "Label";
    import "Popup";
    import "Wizard";
    import "Report";
    import "Sequencer";


    // screen title - installation source configuration
    string title = _("Installation Source");


    list<integer> sources = Pkg::SourceGetCurrent (false);

    map<string,any> sconfig = VM::GetSourceConfig();

    define term create_item (integer index, integer id) ``{
        map product_data = Pkg::SourceProductData (id);
        map general_data = Pkg::SourceGeneralData (id);
        return `item (`id (index),
		      product_data["label"]:"unknown",
		      general_data["url"]:"");
    }


    define void fill_table () ``{

	integer i = 0;
        list items = [];
	integer j = -1;

        while (i < size (sources))
	{
	    items = add (items, create_item (i, sources[i]:0));
	    if (sources[i]:0 == sconfig["source_id"]:0)
		j = i;
	    i = i + 1;
        }

        UI::ChangeWidget (`id (`sources), `Items, items);
	if (j > -1)
	    UI::ChangeWidget (`id(`sources), `CurrentItem, j);
    }

    define void updateConfig(map<string,any> conf) {
	y2debug("updateConfig(%1)", conf);
	VM::SetSourceConfig(conf["source_id"]:0, conf["inst_type"]:`configured, conf["custom"]:"");
    }

    define void RefreshSourceTypeDialog()
    {
	boolean enabled = (symbol) UI::QueryWidget (`id(`rbg), `CurrentButton) == `custom;
	UI::ChangeWidget(`id(`kernel), `Enabled, enabled);
	UI::ChangeWidget(`id(`select_kernel), `Enabled, enabled);
	UI::ChangeWidget(`id(`initrd), `Enabled, enabled);
	UI::ChangeWidget(`id(`select_initrd), `Enabled, enabled);
    }

    /**
     * Popup dialog - source configuration
     * return symbol
     */
    define symbol SourceTypeDialog() {

	string help_text = _("<P><B>Operating System</B></P>") +

	_("<P>The kernel for the virtual machine can be extracted from the selected
installation source or it can be selected explicitly. This is useful if
the source does not contain required packages or if you want to use another
operating system. RAM disk configuration is optional.</P>
");

	term contents =
	    `Frame(_("Disk Image"),
		`MarginBox(2, 0.3,
		    // heading in a popup dialog
		    `RadioButtonGroup(`id(`rbg),
			`VBox(
			    `VSpacing(0.3),
			    `Left(`RadioButton(`id(`extract), `opt(`notify), _("&Extract Kernel and RAM Disk Image from an Installation Source"))),
			    `VSpacing(1),
			    `Left(`RadioButton(`id(`custom), `opt(`notify), _("Use &Custom Kernel and RAM Disk Image Files"))),
//			    `VSpacing(0.2),
			    `HBox(
				`HSpacing(3),
				`TextEntry(`id(`kernel), `opt(`hstretch), _("&Kernel Image"), VM::GetKernelImage()),
				`HSpacing(1),
				`VBox(
				    `Label(""),
				    `PushButton(`id(`select_kernel), _("Select Image..."))
				)
			    ),
//			    `VSpacing(0.2),
			    `HBox(
				`HSpacing(3),
				`TextEntry(`id(`initrd), `opt(`hstretch), _("&RAM Disk Image"), VM::GetInitrdImage()),
				`HSpacing(1),
				`VBox(
				    `Label(""),
				    `PushButton(`id(`select_initrd), _("Select Image..."))
				)
			    ),
			    `VSpacing(0.2)
			)
		    )
		)
	    );

	Wizard::SetContents(_("Operating System"), contents, help_text, true, true);

	symbol s = `dummy;

	UI::ChangeWidget(`id(`rbg), `CurrentButton, (VM::GetCustomKernel()) ? `custom : `extract);

	// initialize the widgets
	RefreshSourceTypeDialog();

	while(!contains([`next, `back, `abort, `cancel, `fetch], s))
	{
	    s = (symbol) UI::UserInput();

	    if (s == `next)
	    {
		symbol type = (symbol) UI::QueryWidget (`id(`rbg), `CurrentButton);

		if (type == `custom)
		{
		    string kernel = (string) UI::QueryWidget (`id(`kernel), `Value);
		    string initrd = (string) UI::QueryWidget (`id(`initrd), `Value);

		    if (kernel == nil || kernel == "")
		    {
			Report::Error("The kernel image file name cannot be empty.");
			s = `again;
			continue;
		    }

		    VM::SetCustomKernel(true);

		    VM::SetKernelImage(kernel);
		    VM::SetInitrdImage(initrd);

		    // set no installation source
		    sconfig["inst_type"] = `none;
		    updateConfig(sconfig);
		}
		else
		{
		    s = `fetch;
		    VM::SetCustomKernel(false);
		}
	    }
	    else if (s == `select_kernel)
	    {
		string new_kernel = (string)UI::QueryWidget(`id(`kernel), `Value);
		new_kernel = UI::AskForExistingFile(new_kernel, "*", _("Select Kernel Image"));

		if (new_kernel != nil)
		{
		    UI::ChangeWidget(`id(`kernel), `Value, new_kernel);
		}
	    }
	    else if (s == `select_initrd)
	    {
		string new_initrd = (string)UI::QueryWidget(`id(`initrd), `Value);
		new_initrd = UI::AskForExistingFile(new_initrd, "*", _("Select RAM Disk Image"));

		if (new_initrd != nil)
		{
		    UI::ChangeWidget(`id(`initrd), `Value, new_initrd);
		}
	    }
	    else if (s == `custom || s == `extract)
	    {
		// refresh the dialog
		RefreshSourceTypeDialog();
	    }
	}

	boolean custom = (symbol) UI::QueryWidget (`id(`rbg), `CurrentButton) == `custom;
	boolean old_setting = VM::GetCustomKernel();

	// if kernel type has been changed ask user to reset kernel options
	if ((s == `fetch || s == `next) && old_setting != custom)
	{
	    string current = sformat(_("Current Arguments: %1
Current Installation Arguments: %2"), VM::GetExtraArgs(), VM::GetExtraInstArgs());

	    string question = (custom) ? sformat(_("Set empty arguments for the selected kernel?\n%1"), current) :
		sformat(_("Set default SUSE Linux installation arguments for kernel?\n%1"), current);

	    if (Popup::YesNo(question))
	    {
		VM::ResetExtraArgs();
		VM::ResetExtraInstArgs();
	    }
	}

	return s;
    }


define symbol SourceSelection() {
    // build and show dialog
    integer indent = 3;

    term contents = `VBox(
			`RadioButtonGroup(`id(`source), `opt(`notify),
			    `VBox(
				`VSpacing(0.3),
				// radio button label
				`Left(`RadioButton(`id(`configured),  `opt(`notify), _("&Configured Installation Source"), sconfig["inst_type"]:`unknown == `configured)),
				`VSpacing(0.3),
				`HBox(
				    `HSpacing(indent),
				    `Table(`id(`sources),
					// table column heading
					`header(_("Name"), _("URL")), [ ])
				),
				// push button label
				// installation source configuration module
				// is started when it's pressed
				`PushButton(`id(`inst_src), _("C&onfigure...")),
				`VSpacing(1),

				`Left(`RadioButton(`id(`custom),  `opt(`notify), _("Custom &Installation Source"), sconfig["inst_type"]:`unknown == `custom)),
				`HBox(
				    `HSpacing(indent),
				    `TextEntry(`id(`custom_source), _("&URL of Installation Source"), sconfig["custom_source"]:"")
				),
				`VSpacing(1)

// TODO: disabled, we need kernel package before starting VM, we MUST know the URL
//				`Left(`RadioButton(`id(`slp),  `opt(`notify), _("&SLP Installation Source"), sconfig["inst_type"]:`unknown == `slp)),
//				`VSpacing(1)
			    )
			)
		    );

    // help text for backup dialog during update 1/7
    string help_text = _("<P><B>Installation Source</B></P>")
    + _("<P>Select the installation source from which to install the virtual machine.</P>");
//    + _("<P>Only network installation sources, such as FTP or NFS, are supported.</P>");

    Wizard::SetContents(title, contents, help_text, true, true);

    fill_table();

    symbol ret = nil;

    while (true)
    {
	// refresh status of the widgets
	symbol selected = (symbol)(UI::QueryWidget(`id(`source), `CurrentButton));
	UI::ChangeWidget(`id(`sources), `Enabled, selected == `configured);
	UI::ChangeWidget(`id(`inst_src), `Enabled, selected == `configured);
	UI::ChangeWidget(`id(`custom_source), `Enabled, selected == `custom);

	ret = (symbol) Wizard::UserInput ();

	if (ret == `abort && Popup::ConfirmAbort (`painless))
	    break;

	if (ret == `cancel || ret == `back)
	    break;

	if (ret == `next)
	{
	    // check if selected installation source is valid
	    integer current = (integer) UI::QueryWidget (`id(`sources), `CurrentItem);

	    y2milestone("sources: %1, current: %2", sources, current);
	    integer current_srcid = -1;
	    if (size(sources) > 0)
	    {
		current_srcid = sources[current]:0;
	    }

	    symbol selected_type = (symbol)UI::QueryWidget(`id(`source), `CurrentButton);
	    string selected_custom_source = (string)UI::QueryWidget(`id(`custom_source), `Value);
	    string srcurl = "";

	    if (selected_type == `configured)
	    {
		if (current_srcid >= 0)
		{
		    map general_data = Pkg::SourceGeneralData(current_srcid);
		    srcurl = general_data["url"]:"";
		}
	    }
	    else
	    {
		srcurl = selected_custom_source;
	    }

	    map parsed_url = URL::Parse(srcurl);

	    if (!URL::Check(srcurl) || parsed_url["host"]:"" == "")
	    {
		Report::Error(_("Entered URL value is not valid."));
	    }
	    else
	    {
		y2debug("Selected source: %1", srcurl);
		sconfig["inst_type"] = selected_type;

		if (selected_type == `configured)
		{
		    sconfig["source_id"] = current_srcid;
		}
		else if (selected_type == `custom)
		{
		    sconfig["custom"] = selected_custom_source;
		}
		else
		{
		    y2error("Unknown installation type");
		}

		updateConfig(sconfig);

		break;
	    }
/*	    else
	    {
		Report::Error(_("Only network installation sources
are supported in the installation."));
	    }*/
	}

	if (ret == `inst_src)
	{
	    // start installation source configuration module
	    WFM::CallFunction("inst_source", []);
	    // refresh table content
	    sources = Pkg::SourceGetCurrent(false);
	    fill_table();
	}
    }

    return ret;
}

define void RefreshFullOptionsDialog()
{
    boolean enabled = (symbol) UI::QueryWidget (`id(`rb_group), `CurrentButton) == `cdrom;

    UI::ChangeWidget(`id(`cdromimage), `Enabled, enabled);
    UI::ChangeWidget(`id(`select_file), `Enabled, enabled);
}

define symbol FullOptionsDialog()
{
    // screen title for the Xen mode selection
    string title = _("Operating System");

    map<string,string> fulloption = VM_XEN::GetFullOptions();
    string cd = fulloption["cdrom_image"]:"";
    string boot = fulloption["boot_device"]:"c";

    y2milestone("VTx config: cdrom_image: %1, boot_device: %2", cd, boot);

    term contents = `HBox(
	`HSpacing(2),
	`RadioButtonGroup(`id(`rb_group),
	    `Frame(_("Boot System From"),
		`VBox(
		    `VSpacing(0.5),
		    `Left(`RadioButton(`id(`cdrom), `opt(`notify), _("CD-ROM Device"), boot == "d")),
		    `HBox(
                        `HSpacing(2),
                        `TextEntry(`id(`cdromimage), `opt(`hstretch), _("&ISO Image File"), cd),
                        `HSpacing(1),
                        `VBox(
                            `Label(""),
                            `PushButton(`id(`select_file), _("Select Image..."))
                        ),
                        `HSpacing(1)
		    ),
		    `VSpacing(0.5),
		    `Left(`RadioButton(`id(`disk), `opt(`notify), _("Hard Disk"), boot == "c")),
		    `VSpacing(0.5)
		)
	    )
	),
	`HSpacing(2)
    );

    // help text for OS selection in full virtualization mode (1/3)
    string help_text = _("<B><BIG>Fully Virtualized Operating System</BIG></B>")
	// help text for OS selection in full virtualization mode (2/3)
	+ _("<P>The new virtual machine can be booted from a CDROM or hard disk.</P>")
	// help text for OS selection in full virtualization mode (3/3)
	+ _("<P>It is assumed a new OS installation will occur if the VM is booted
from a CDROM. In this case, after the installation the virtual machine will be
booted from hard disk.</P>");

    Wizard::SetContents (title, contents, help_text, true, true);

    symbol ret = nil;

    while (true)
    {
	RefreshFullOptionsDialog();

	ret = (symbol) Wizard::UserInput();

	if (ret == `abort && Popup::ConfirmAbort(`painless))
	    break;

	if (ret == `cancel || ret == `back)
	    break;

	if (ret == `next)
	{
	    string bootdev = (symbol)(UI::QueryWidget(`id(`rb_group), `CurrentButton)) == `cdrom ? "d" : "c";
	    string cdimg = (string)(UI::QueryWidget(`id(`cdromimage), `Value));

	    if (bootdev == "d" && cdimg == "")
	    {
		// error - entered empty ISO image file name
		Report::Error(_("Select an ISO image file for CD-ROM emulation."));
	    }
	    else
	    {
		VM_XEN::SetFullOptions( $["boot_device":bootdev, "cdrom_image":cdimg] );
		break;
	    }
	}
	else if (ret == `select_file)
	{
	    string cdimg = (string)(UI::QueryWidget(`id(`cdromimage), `Value));
	    string new_img = UI::AskForExistingFile(cdimg, "*.iso", _("Select ISO Image"));

	    if (new_img != nil)
	    {
		UI::ChangeWidget(`id(`cdromimage), `Value, new_img);
	    }
	}
    }

    return ret;
}

    Wizard::OpenNextBackDialog();

    map aliases = $[
	    "SourceSelection"	: ``(SourceSelection()),
	    "SourceTypeDialog"	: ``(SourceTypeDialog()),
	    "FullOptionsDialog"	: ``(FullOptionsDialog())
	];

    map sequence = $[
	    // start differnt workflow for full virtualization mode
	    "ws_start"	: (VM::GetVirtualizationType() == "full") ? "FullOptionsDialog" : "SourceTypeDialog",
	    "SourceTypeDialog"	:
		$[
		    `fetch	    :	"SourceSelection",
		    `abort	    :   `abort
		],
	    "SourceSelection"	:
		$[
		    `abort	    :   `abort
		],
	    "FullOptionsDialog"	:
		$[
		    `abort	    :   `abort
		]
	    ];

    symbol ret = Sequencer::Run(aliases, sequence);

    Wizard::CloseDialog();

    return ret;

}
