/**
 * Module:	inst_vm_disks.ycp
 *
 * Authors:	Ladislav Slezak <lslezak@suse.cz>
 *
 * Purpose:	Ask the user for virtual disks configuration.
 *
 * $Id$
 *
 */
{
    textdomain "vm";

    import "VM";
    import "Label";
    import "Popup";
    import "Wizard";
    import "Report";
    import "Sequencer";

    // dialog title - virtual disk configuration
    string title = _("Virtual Disks");

    list<map<string,any> > disks = VM::GetDiskConfig();

    integer selected_disk = nil;

    define map<string,any> ask_size (string device, integer s, boolean sparse, boolean ro) ``{

	map<string,any> ret = nil;

	string help_text = _("<P><B>Create Virtual Disk Image</B></P><P>YaST
creates a new disk image of the specified size.</P>
") +

_("<P><B>Virtual Machine Device</B> is the name of the virtual disk inside the virtual machine.</P>") +

_("<P>The image can be configured read-only. In this case, the virtual
machine cannot modify the image in any way.</P>
") +

	_("<P>It is possible to create a <B>sparse image
file</B> that dynamically allocates disk space when it is needed.</P>
");



	term contents =
	`Frame(_("Disk Configuration"),
		`MarginBox(1.5, 0.2,
			// heading in a popup dialog
			`VBox(
			      `ComboBox(`id(`size), `opt(`editable,`hstretch),
					// combobox label
					_("&Disk Size in MB:"),
					["1024", "2048", "4096", "8192"]),
			      `VSpacing(0.5),
			      (VM::GetVMMtype() == "xen") ?
				  // label - disk device widget (enter /dev/hda1, /dev/sdb3...)
				  `TextEntry(`id(`device), `opt(`hstretch), _("&Virtual Machine Device"), device)
			      : `Empty(),

			      `VBox(

			      `VSpacing(0.5),
			      `Left(`CheckBox(`id(`ro), _("&Read-Only Access"), ro)),
			      `VSpacing(0.5),
			      `Left(`CheckBox(`id(`sparse), _("Create &Sparse Image File"), sparse)),
			      `VSpacing(0.2)
			      ))
			));

	Wizard::SetContents(_("Virtual Disk Configuration"), contents, help_text, true, true);

	UI::ChangeWidget (`id(`size), `ValidChars, "0123456789");
	UI::ChangeWidget (`id(`size), `Value, tostring (s));

	symbol ui = `dummy;
	while(!contains([`next, `accept, `back, `abort, `cancel], ui))
	{
	    ui = (symbol) UI::UserInput();
	    y2debug("ui: %1", ui);

	    if (ui == `next || ui == `accept)
	    {
		boolean sparse_file = (boolean) UI::QueryWidget (`id(`sparse), `Value);
		string dev = (VM::GetVMMtype() == "xen") ? (string) UI::QueryWidget (`id(`device), `Value) : "";
		string sz = (string)UI::QueryWidget (`id(`size), `Value);
		integer sz_int = tointeger(sz) ;
		boolean new_ro = (boolean) UI::QueryWidget (`id(`ro), `Value);

		if (dev == nil || dev == "")
		{
		    // error message
		    Report::Error(_("Device name cannot be empty."));
		    ui = `again;
		}
		else if (sz_int == nil)
		{
		    // error message
		    Report::Error(_("Device size is invalid."));
		    ui = `again;
		}
		else
		{
		    ret = $[ "size" : sz_int, "sparse" : sparse_file, "type" : "loop-create", "ro" : new_ro ];

		    if (VM::GetVMMtype() == "xen") {
			ret = add(ret, "target", dev);
			ret = add(ret, "source", dev);
		    }
		}
	    }
	}

	y2debug("ret: %1", ret);
	return ret;
    }

    define map<string,any> UseLoopBackDialog(string device, string source, boolean ro) ``{

	map<string,any> ret = nil;

	string help_text = _("<P><B>Use Virtual Disk Image</B>: An existing disk image can used by the virtual machine.</P>") +

_("<P>The image can be configured read-only. In this case, the virtual
machine cannot modify the image in any way.</P>
") +

_("<P><B>Virtual Machine Device</B> is the name of the virtual disk inside the virtual machine.</P>");

	term contents = `Frame(_("Disk Configuration"),
	    `MarginBox(1.5, 0.2,
		// heading in a popup dialog
		`VBox(
		    `HBox(
			`TextEntry(`id(`source), `opt(`hstretch), _("&Disk Image File"), source),
			`HSpacing(1),
			`VBox(
			    `Label(""),
			    `PushButton(`id(`select_file), _("Select Image..."))
			)
		    ),
		    `VSpacing(0.5),
		    (VM::GetVMMtype() == "xen") ?
			// label - disk device widget (enter /dev/hda1, /dev/sdb3...)
			`TextEntry(`id(`device), `opt(`hstretch), _("&Virtual Machine Device"), device)
		    : `Empty(),

		    `VSpacing(0.5),
		    `Left(`CheckBox(`id(`ro), _("&Read-Only Access"), ro)),
		    `VSpacing(0.2)
		)
	    )
	);

	Wizard::SetContents(_("Virtual Disk Configuration"), contents, help_text, true, true);

	symbol ui = `dummy;
	while(!contains([`next, `accept, `back, `abort, `cancel], ui))
	{
	    ui = (symbol) UI::UserInput();
	    string new_src = (string) UI::QueryWidget (`id(`source), `Value);

	    if (ui == `next || ui == `accept)
	    {
		string dev = (VM::GetVMMtype() == "xen") ? (string) UI::QueryWidget (`id(`device), `Value) : "";
		boolean new_ro = (boolean) UI::QueryWidget (`id(`ro), `Value);

		if (dev == nil || dev == "")
		{
		    // error message
		    Report::Error(_("Device name cannot be empty."));
		    ui = `again;
		}
		else if (new_src == nil || new_src == "")
		{
		    // error message
		    Report::Error(_("Source file name is missing."));
		    ui = `again;
		}
		else
		{
		    // check whether the file exists
		    if ((integer)SCR::Read(.target.size, new_src) < 0)
		    {
			// %1 is file name
			Report::Error(sformat(_("File %1 does not exist."), new_src));
			continue;
		    }
		    ret = $[ "source" : new_src, "type" : "loop-use", "ro" : new_ro ];

		    if (VM::GetVMMtype() == "xen") {
			ret = add(ret, "target", dev);
		    }
		}
	    }
	    else if (ui == `select_file)
	    {
		new_src = UI::AskForExistingFile(new_src, "*", _("Select Disk Image"));

		if (new_src != nil)
		{
		    UI::ChangeWidget(`id(`source), `Value, new_src);
		}
	    }
	}

	y2debug("ret: %1", ret);
	return ret;
    }

    /**
     * Popup dialog - disk configuration
     * @param device target device in a VM
     * @param phys source (physical) device (in dom0)
     * @param ro true = read only access, false = read/write access
     */
    define map<string,any> ask_disk(string device, string phys, boolean ro) ``{

	list<map> devmap = (list<map>)SCR::Read(.proc.partitions);
	y2milestone("current partitions (/proc/partitions): %1", devmap);

	list<term> devs = [];

	if (devmap != nil)
	{
	    foreach(map d, devmap, {
		    string name = d["name"]:"";

		    if (name != nil && name != "")
		    {
			devs = add(devs, `item(`id(name), "/dev/" + name));
		    }
		}
	    );
	}

	string help_text = _("<P><B>Block Device</B>: The virtual machine can use only block devices accessible from domain 0.</P>") +

_("<P><B>Virtual Machine Device</B> is the name of the virtual device presented to the virtual machine.") +

_("<P>The block device can be configured <B>read-only</B>. In this case, the virtual
machine cannot modify the device in any way.</P>
");




	term contents =

	`Frame(_("Disk Configuration"),
		`MarginBox(2, 0.3,
			// heading in a popup dialog
			`VBox(
			    `ComboBox(`id(`phys), `opt(`editable, `hstretch), _("Block Device (Source)"), devs),
			    `VSpacing(0.8),
			    // label - disk device widget (enter /dev/hda1, /dev/sdb3...)
			    `TextEntry(`id(`device), `opt(`hstretch), _("&Virtual Machine Device (Target)"), device),

			    `VSpacing(1),
			    `Left(`CheckBox(`id(`ro), _("&Read-Only Access"), ro)),
			    `VSpacing(0.8)
			  )
		    ));

	Wizard::SetContents(_("Virtual Disk Configuration"), contents, help_text, true, true);
	UI::ChangeWidget(`id(`phys), `Value, phys);

	symbol s = `dummy;
	string new_dev = "";
	string new_phys = "";

	while(!contains([`next, `back, `abort, `cancel], s))
	{
	    s = (symbol) UI::UserInput();

	    if (s == `next)
	    {
		new_dev = (string) UI::QueryWidget (`id(`device), `Value);
		new_phys = (string) UI::QueryWidget (`id(`phys), `Value);

		if (new_phys == "" || new_dev == "")
		{
		    // error message
		    Report::Error(_("Device name cannot be empty."));
		    s = `again;
		}
	    }
	}

	boolean new_ro = (boolean) UI::QueryWidget (`id(`ro), `Value);

//	UI::CloseDialog();

	if (s != `next)
	{
	    return nil;
	}

	map<string,any> ret = $[ "source" : new_phys, "target" : new_dev, "ro" : new_ro, "type" : "phys" ];

	y2debug("ret: %1", ret);
	return ret;
    }

    /**
     * Popup dialog - disk configuration
     * @param device target device in a VM
     * @param phys source (physical) device (in dom0)
     * @param ro true = read only access, false = read/write access
     */
    define symbol LoopbackTypeDialog() {

	// help text
	string help_text = _("<P><B>Loopback File Configuration</B></P><P>An existing disk image can be assigned to the virtual machine or it is possible to create a new empty disk image.</P>");

	term contents =
	    `Frame(_("Disk Image"),
		`MarginBox(2, 0.3,
		    // heading in a popup dialog
		    `RadioButtonGroup(`id(`rbg),
			`VBox(
			    `VSpacing(1),
			    `Left(`RadioButton(`id(`create), _("&Create New Disk Image"), true)),
			    `VSpacing(1),
			    `Left(`RadioButton(`id(`use), _("&Use Existing Disk Image"))),
			    `VSpacing(0.8)
			)
		    )
		)
	    );

	Wizard::SetContents(_("Configuration of Disk Image"), contents, help_text, true, true);

	symbol s = `dummy;

	while(!contains([`next, `back, `abort, `cancel], s))
	{
	    s = (symbol) UI::UserInput();
	}

	if (s == `next)
	{
	    s = (symbol) UI::QueryWidget (`id(`rbg), `CurrentButton);
	}

	return s;
    }


    define void refresh_table(list<map<string,any> > disks)
    {
	integer id_cnt = 0;
	list <term> d = [];
	list<map> devmap = (list<map>)SCR::Read(.proc.partitions);

	map<string,integer> device_sizes = $[];

	foreach(map device, devmap, {
		string name = device["name"]:"";
		integer sz = device["size"]:0;

		if (name != nil && name != "")
		{
		    device_sizes = add(device_sizes, name, sz);
		}
	    }
	);

	y2milestone("device_sizes: %1", device_sizes);

	foreach (map<string,any> m, disks, ``{

	    string sz = "";

	    if (haskey(m, "size"))
	    {
		sz = tostring(m["size"]:0);
	    }

	    y2milestone("disk: %1", m);

	    if (m["type"]:"" == "phys")
	    {
		// get size of the device, it's in sectors (512B)   (x*0.5 = x*512/1024)
		sz = tostring((device_sizes[m["source"]:""]:0) / 1024);
	    }
	    y2milestone("sz: %1", sz);

	    if (VM::GetVMMtype() == "xen") {
		string prefix = "";

		if (m["type"]:"" == "loop-create")
		{
		    prefix = "/var/lib/xen/images/";
		}
		else if (m["type"]:"" == "phys")
		{
		    prefix = "/dev/";
		}

		d = add(d, `item (`id(id_cnt), m["target"]:"", prefix + m["source"]:"", sz, (m["ro"]:false) ? UI::Glyph(`CheckMark) : "", (m["sparse"]:false) ? UI::Glyph(`CheckMark) : ""));
	    }
	    else if (VM::GetVMMtype() == "uml") {
		d = add(d, `item (`id(id_cnt), m["size"]:0, (m["ro"]:false) ? UI::Glyph(`CheckMark) : "", (m["sparse"]:false) ? UI::Glyph(`CheckMark) : ""));
	    }

	    id_cnt = id_cnt + 1;
	});
	UI::ChangeWidget (`id(`disks), `Items, d);
    }

define symbol DiskOverview() {
    // build and show dialog

    term heading = (VM::GetVMMtype() == "uml") ?
		// table - column heading
		`header (`Right(_("Disk Size (MB)")), `Center(_("Sparse File")))
	    :
		// table - column heading
		`header (_("Virtual Device"), _("Source"), `Right(_("Disk Size (MB)")), `Center(_("Read Only")), `Center(_("Sparse File")));

    term contents = `VBox(
			`Table(`id(`disks),
			    heading, []
			),
			`HBox(
			    // add dots - %1 is translated 'Add' button label
			    `MenuButton (sformat(_("%1..."), Label::AddButton()),
			    // Menu item
				[ `item(`id(`add_loop), _("Add Loopback Device...")), `item(`id(`add_phys), _("Add Block Device...")) ]),
			    `PushButton (`id (`edit), Label::EditButton()),
			    `PushButton (`id (`delete), Label::DeleteButton())
			)
		    );

    // help text for disk setup
    string help_text = _("<P><B>Virtual Disk Setup<B></P>")
    + _("<P>Here, configure number and size of virtual disks.
The content of each virtual disk is stored in a file in the host system.</P>
");

    // TODO: add sparse option help text

    Wizard::SetContents (title, contents, help_text, true, true);
    Wizard::SetNextButton(`next, Label::OKButton());

    refresh_table(disks);

    symbol ret = nil;

    while (true)
    {
	ret = (symbol) Wizard::UserInput();

	if (ret == `abort && Popup::ConfirmAbort (`painless))
	    break;

	if (ret == `cancel || ret == `back || ret == `add_loop || ret == `add_phys)
	    break;

	if (ret == `edit)
	{
	    selected_disk = (integer) UI::QueryWidget (`id(`disks), `CurrentItem);
	    break;
	}

	if (ret == `delete)
	{
	    integer id = (integer) UI::QueryWidget (`id(`disks), `CurrentItem);

	    if (id != nil)
	    {
		list<map<string,any> > new_disks = [];

		foreach(map<string,any> m, disks, ``{
			if (id != 0)
			{
			    new_disks = add(new_disks, m);
			}
			id = id - 1;
		    }
		);

		disks = new_disks;
		refresh_table(disks);
	    }
	}

	if (ret == `next)
	{
	    if (size (disks) <= 0)
	    {
		// error popup
		string message = _("At least one disk is required.");
		Popup::Message (message);
		continue;
	    }

	    VM::SetDiskConfig(disks);
	    break;
	}
    }

    Wizard::RestoreNextButton();

    return ret;
}


symbol AddLoopBack() {
    map<string,any> m = ask_size("", 1024, true, false);
    symbol ret = `back;

    if (m != nil)
    {
	disks = add(disks, m);
	ret = `next;
    }

    y2milestone("AddLoopBack: %1", ret);

    return ret;
}

symbol AddImageLoopBack() {
    map<string,any> m = UseLoopBackDialog("", "", false);
    symbol ret = `back;

    if (m != nil)
    {
	disks = add(disks, m);
	ret = `next;
    }

    y2milestone("AddImageLoopBack: %1", ret);

    return ret;
}

symbol AddPhysical() {
    map<string,any> m = ask_disk("hda", "", true);

    symbol ret = `back;

    if (m != nil)
    {
	disks = add(disks, m);
	ret = `next;
    }

    y2milestone("AddPhysical: %1", ret);

    return ret;
}

symbol EditDisk() {
    if (selected_disk != nil)
    {
	// check whether the current disk is physical or loopback mounted

	map<string,any> d = disks[selected_disk]:$[];

	if (d["type"]:"" == "phys")
	{
	    d = ask_disk(d["target"]:"", d["source"]:"", d["ro"]:true);
	}
	else if (d["type"]:"" == "loop-create")
	{
	    d = ask_size(d["target"]:"", d["size"]:0, d["sparse"]:false, d["ro"]:false);
	}
	else if (d["type"]:"" == "loop-use")
	{
	    d = UseLoopBackDialog(d["target"]:"", d["source"]:"", d["ro"]:false);
	}
	else
	{
	    y2error("Unknown disk type %1", d["type"]:"");
	}

	if (d != nil)
	{
	    disks[selected_disk] = d;
	}
    }

    return `next;
}


    Wizard::OpenNextBackDialog();

    map aliases = $[
	    "DiskOverview"	: ``(DiskOverview()),
	    "AddLoopBack"	: ``(AddLoopBack()),
	    "AddImageLoopBack"	: ``(AddImageLoopBack()),
	    "LoopBackType"	: ``(LoopbackTypeDialog()),
	    "AddPhysical"	: ``(AddPhysical()),
	    "EditDisk"		: ``(EditDisk()),
	];

    map sequence = $[
	    "ws_start"	: "DiskOverview",
	    "DiskOverview"	:
		$[
		    `next	    :	`next,
		    `add_loop	    :	"LoopBackType",
		    `add_phys	    :	"AddPhysical",
		    `edit	    :	"EditDisk",
		    `abort	    :   `abort
		],
	    "LoopBackType"	:
		$[
		    `create	    :	"AddLoopBack",
		    `use	    :   "AddImageLoopBack",
		    `abort	    :   `abort
		],
	    "AddLoopBack"	:
		$[
		    `next	    :	"DiskOverview",
		    `abort	    :   `abort
		],
	    "AddImageLoopBack"	:
		$[
		    `next	    :	"DiskOverview",
		    `abort	    :   `abort
		],
	    "AddPhysical"	:
		$[
		    `next	    :	"DiskOverview",
		    `abort	    :   `abort
		],
	    "EditDisk"	:
		$[
		    `next	    :	"DiskOverview",
		    `abort	    :   `abort
		]
	    ];


    symbol ret = Sequencer::Run(aliases, sequence);

    Wizard::CloseDialog();

    return ret;
}
